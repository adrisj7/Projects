<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Physics (TODO: Inherit?)

_velX = 0;
_velY = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Character changeble properties

// Sprites
_charWalkSheet = sprExampleCharsheet;

// Walking
_walkSpeed = 2.8;

// Sprite scroll speed.
_walkCycleScrollSpeed = 0.13;

// Snap properties (snap to grid while walking). Should this be defined here?...
_snapX = TILE_WIDTH;
_snapY = TILE_HEIGHT;

// Snap offsets, by what value should our snap be offset?
_snapXoffset = TILE_WIDTH/2;
_snapYoffset = TILE_HEIGHT/2;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Character util variables

enum DIRECTION {
    LEFT,
    RIGHT,
    UP,
    DOWN
};

// What way are we facing?
_facing = DIRECTION.RIGHT;

// Walk cycle
_walkCycleCounter = 0;

// Movement variables controlling player movement
_moveInputX = 0;
_moveInputY = 0;

// Move inputs that don't ever reset to zero
_nonZeroMoveInputX = 0;
_nonZeroMoveInputY = 0;

// Were we moving last frame?
_lastMoving = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Move by velocity (TODO: Inherit?)

x += _velX;
y += _velY;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handle movement

// Set non-zero inputs
if _moveInputX != 0
    _nonZeroMoveInputX = _moveInputX;
if _moveInputY != 0
    _nonZeroMoveInputY = _moveInputY;

// Are we moving?
var moving = (_moveInputX != 0 || _moveInputY != 0);

// Start walking with a prep in our step instead of sliding like a phantom
if moving &amp;&amp; !_lastMoving {
    _walkCycleCounter = 1;
}

if moving {

    var moveSpd = _walkSpeed;

    // Snap

    // If we're not moving left or right, snap left/right.
    if _moveInputX == 0 &amp;&amp; _nonZeroMoveInputX != 0 {
        // The target grid X position that we're moving towards.
        var targetGridX = _snapXoffset + _snapX * (floor((x - _snapXoffset) / _snapX) + clamp(_nonZeroMoveInputX, 0, 1));
        var deltaX = targetGridX - x;
        // The speed that we WOULD move at if we traveled in our direction.
        var targetSpeedX = lengthdir_x(moveSpd, 45);
        if abs(deltaX) &lt;= targetSpeedX {
            x = targetGridX;
            _nonZeroMoveInputX = 0;
        } else {
            _moveInputX = sign(deltaX);
        }
    }
    if _moveInputY == 0 &amp;&amp; _nonZeroMoveInputY != 0 {
        // The target grid Y position that we're moving towards.
        var targetGridY = _snapYoffset + _snapY * (floor((y - _snapYoffset) / _snapY) + clamp(_nonZeroMoveInputY, 0, 1));
        var deltaY = targetGridY - y;
        // The speed that we WOULD move at if we traveled in our direction.
        var targetSpeedY = abs(lengthdir_y(moveSpd, 45));
        if abs(deltaY) &lt;= targetSpeedY {
            y = targetGridY;
            _nonZeroMoveInputY = 0;
        } else {
            _moveInputY = sign(deltaY);
        }
    }

    // Actually move the player
    var angle = point_direction(0, 0,_moveInputX, _moveInputY);
    _velX = lengthdir_x(moveSpd, angle);
    _velY = lengthdir_y(moveSpd, angle);

    // Setting our facing direction
    var needToChangeDirection = false;
    switch _facing {
        case DIRECTION.LEFT:
            if _moveInputX != -1
                needToChangeDirection = true;
            break;
        case DIRECTION.RIGHT:
            if _moveInputX != 1
                needToChangeDirection = true;
            break;
        case DIRECTION.UP:
            if _moveInputY != -1
                needToChangeDirection = true;
            break;
        case DIRECTION.DOWN:
            if _moveInputY != 1
                needToChangeDirection = true;
            break;
    }
    if needToChangeDirection {
        if _moveInputX &gt; 0
            _facing = DIRECTION.RIGHT;
        else if _moveInputX &lt; 0
            _facing = DIRECTION.LEFT;
        else if _moveInputY &gt; 0
            _facing = DIRECTION.DOWN;
        else
            _facing = DIRECTION.UP;
    }

    // Walk cycle
    _walkCycleCounter += _walkCycleScrollSpeed;
} else {
    _velX = 0;
    _velY = 0;
    _walkCycleCounter = 0;
}

_lastMoving = moving;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw sprite animated

// How many images per cycle (traditionally it's 4.
var cycleFrameCount = 4;

var subIndex = wrap(_walkCycleCounter, 0, cycleFrameCount);

var offset = 0;
switch (_facing) {
    case DIRECTION.LEFT:
        offset = 1;
        break;
    case DIRECTION.RIGHT:
        offset = 2;
        break;
    case DIRECTION.UP:
        offset = 3;
        break;
    case DIRECTION.DOWN:
        offset = 0;
        break;
}
// Open up the sprite to see why we scale this.
offset *= cycleFrameCount;

draw_sprite(_charWalkSheet, offset + subIndex, x, y);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
