<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>sprExampleCharsheet</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>maskPlayerFeet</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Physics (TODO: Inherit?)

_velX = 0;
_velY = 0;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Character changeble properties

// Sprites
_charWalkSheet = sprExampleCharsheet;

// Walking
_walkSpeed = 2.0;

// Sprite scroll speed.
_walkCycleScrollSpeed = 0.08;

// Is snap enabled? This should be a setting, and should be turned off
// when in a boss fight.
_snapEnabled = true;

// Snap properties (snap to grid while walking). Should this be defined here?...
_snapX = TILE_WIDTH;
_snapY = TILE_HEIGHT;

// Snap offsets, by what value should our snap be offset?
_snapXoffset = TILE_WIDTH/2;
_snapYoffset = TILE_HEIGHT/2;

// At what point should we snap back?
// If left to zero, it will always snap in the direction you last traveled.
_snapBufferX = 12;
_snapBufferY = _snapBufferX;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Character util variables

enum DIRECTION {
    LEFT,
    RIGHT,
    UP,
    DOWN
};

// What way are we facing?
_facing = DIRECTION.RIGHT;

// Walk cycle
_walkCycleCounter = 0;

// Movement variables controlling player movement
_moveInputX = 0;
_moveInputY = 0;

// Move inputs that don't ever reset to zero
_nonZeroMoveInputX = 0;
_nonZeroMoveInputY = 0;

// Were we moving last frame?
_lastMoving = false;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Z
z = 0;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// depth = -y;

depth = -y;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Handle movement

// Set non-zero inputs
if _moveInputX != 0
    _nonZeroMoveInputX = _moveInputX;
if _moveInputY != 0
    _nonZeroMoveInputY = _moveInputY;

// Are we moving?
var moving = (_moveInputX != 0 || _moveInputY != 0);

// Start walking with a prep in our step instead of sliding like a phantom
if moving &amp;&amp; !_lastMoving {
    _walkCycleCounter = 1;
}

if moving {

    var moveSpd = _walkSpeed;

    // Snap
    if _snapEnabled {
        // If we're not moving left or right, snap left/right.
        if _moveInputX == 0 &amp;&amp; _nonZeroMoveInputX != 0 {
            // The target grid X position that we're moving towards.
            var targetGridX = _snapXoffset + _snapX * (floor((x - _snapXoffset) / _snapX) + clamp(_nonZeroMoveInputX, 0, 1));
            var closerGridX = _snapXoffset + _snapX * (round((x - _snapXoffset) / _snapX) + clamp(_nonZeroMoveInputX, 0, 1));
            var deltaX = targetGridX - x;
            var deltaCloseX = closerGridX - x;
            // The speed that we WOULD move at if we traveled in our direction.
            var targetSpeedX = lengthdir_x(moveSpd, 45);
            if abs(deltaCloseX) &lt;= _snapBufferX {
                if abs(deltaCloseX) &lt;= targetSpeedX {
                    //x = closerGridX;
                    _velX = deltaCloseX;
                    _nonZeroMoveInputX = 0;
                } else {
                    _moveInputX = sign(deltaCloseX);
                }
            } else {
                if abs(deltaX) &lt;= targetSpeedX {
                    //x = targetGridX;
                    _velX = deltaX;
                    _nonZeroMoveInputX = 0;
                } else {
                    _moveInputX = sign(deltaX);
                }
            }
        }
        if _moveInputY == 0 &amp;&amp; _nonZeroMoveInputY != 0 {
            // The target grid Y position that we're moving towards.
            var targetGridY = _snapYoffset + _snapY * (floor((y - _snapYoffset) / _snapY) + clamp(_nonZeroMoveInputY, 0, 1));
            var closerGridY = _snapYoffset + _snapY * (round((y - _snapYoffset) / _snapY) + clamp(_nonZeroMoveInputY, 0, 1));
            var deltaY = targetGridY - y;
            var deltaCloseY = closerGridY - y;
            // The speed that we WOULD move at if we traveled in our direction.
            var targetSpeedY = abs(lengthdir_y(moveSpd, 45));
            if abs(deltaCloseY) &lt;= _snapBufferY {
                if abs(deltaCloseY) &lt;= targetSpeedY {
                    //y = closerGridY;
                    _velY = deltaCloseY;
                    _nonZeroMoveInputY = 0;
                } else {
                    _moveInputY = sign(deltaCloseY);
                }            
            } else {
                if abs(deltaY) &lt;= targetSpeedY {
                    //y = targetGridY;
                    _velY = deltaY;
                    _nonZeroMoveInputY = 0;
                } else {
                    _moveInputY = sign(deltaY);
                }
            }
        }
    }

    // Actually move the player
    var angle = point_direction(0, 0,_moveInputX, _moveInputY);
    _velX = lengthdir_x(moveSpd, angle);
    _velY = lengthdir_y(moveSpd, angle);

    // Setting our facing direction
    
    // Stop "wall hugging"
    if _moveInputY != 0 &amp;&amp; tileset_meeting(x + sign(_velX), y) {
        _moveInputX = 0;
    }
    if _moveInputX != 0 &amp;&amp; tileset_meeting(x, y + sign(_velY)) {
        _moveInputY = 0;
    }
    var needToChangeDirection = false;
    switch _facing {
        case DIRECTION.LEFT:
            if _moveInputX != -1
                needToChangeDirection = true;
            break;
        case DIRECTION.RIGHT:
            if _moveInputX != 1
                needToChangeDirection = true;
            break;
        case DIRECTION.UP:
            if _moveInputY != -1
                needToChangeDirection = true;
            break;
        case DIRECTION.DOWN:
            if _moveInputY != 1
                needToChangeDirection = true;
            break;
    }
    if needToChangeDirection {
        if _moveInputX &gt; 0
            _facing = DIRECTION.RIGHT;
        else if _moveInputX &lt; 0
            _facing = DIRECTION.LEFT;
        else if _moveInputY &gt; 0
            _facing = DIRECTION.DOWN;
        else if _moveInputY &lt; 0
            _facing = DIRECTION.UP;
    }

    // Walk cycle
    _walkCycleCounter += _walkCycleScrollSpeed;
} else {
    _velX = 0;
    _velY = 0;
    _walkCycleCounter = 0;
}

_lastMoving = moving;
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Collide and move by velocity (TODO: Inherit?)

/**
 * Ok. This collision problem fix is ridiculous.
 * Instead of just checking `` tileset_meeting(x + _velX, y ...)               ``
 * We have to check         `` tileset_meeting(x + _velX + sign(_velX), y ...) ``
 *
 * For some reason there's an extra buffer needed, and I don't like it.
 *
 */


var collisionData = ds_list_create();

if tileset_meeting(x + _velX + sign(_velX), y, collisionData) {
    var tileX = collisionData[| 0];
    if (_velX &gt; 0) {
        _nonZeroMoveInputX = -1;
        var delta = bbox_right - x;
        x = tileX - delta - 1;
    } else if (_velX &lt; 0) {
        _nonZeroMoveInputX = 1;
        var delta = x - bbox_left;
        x = tileX + delta + collisionData[| 2];
    }
    _velX = 0;
    //_nonZeroMoveInputX = 0;
    //_moveInputX = 0;
}
x += _velX;

if tileset_meeting(x, y + _velY + + sign(_velY), collisionData) {
    
    var tileY = collisionData[| 1];
    if (_velY &gt; 0) {
        _nonZeroMoveInputY = -1;
        var delta = bbox_bottom - y;
        y = tileY - delta - 1;
    } else if (_velY &lt; 0) {
        _nonZeroMoveInputY = 1;
        var delta = y - bbox_top;
        y = tileY + delta + collisionData[| 3];
    }
    _velY = 0;
    //_nonZeroMoveInputY = 0;
    //_moveInputY = 0;
}
y += _velY;

ds_list_destroy(collisionData);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw sprite animated

// How many images per cycle (traditionally it's 4.
var cycleFrameCount = 4;

var subIndex = wrap(_walkCycleCounter, 0, cycleFrameCount);

var offset = 0;
switch (_facing) {
    case DIRECTION.LEFT:
        offset = 1;
        break;
    case DIRECTION.RIGHT:
        offset = 2;
        break;
    case DIRECTION.UP:
        offset = 3;
        break;
    case DIRECTION.DOWN:
        offset = 0;
        break;
}
// Open up the sprite to see why we scale this.
offset *= cycleFrameCount;

draw_sprite(_charWalkSheet, offset + subIndex, round(x), round(y - z));

// TEMP draw collision box offset by velocity
/*
draw_set_color(c_red);
draw_rectangle(bbox_left + _velX, bbox_top + _velY, bbox_right + _velX, bbox_bottom + _velY, true);
*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
