<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Sprite Public variables

// Sprite and subimage
_movement_sprite = -1;
_movement_sprite_subimg = 0;
_movement_sprite_left = 0;
_movement_sprite_top = 0;
_movement_sprite_width = 0;
_movement_sprite_height = 0;

// Animation
_movement_frames_per_tile = 2; // default so that every tile we take a step

// Origin (sprite draw offset)
// between 0 and 1
_movement_origin_x = 0;
_movement_origin_y = 0.5;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Sprite Util

// image_index. Start at 1 for resting position
_movement_image_index = 1;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Movement and Orientation Public variables

// Whether to automatically orient the character by the given target values
_auto_orient = true;

_ignore_dialogue = false;
_ignore_collisions = false;

// By default, we don't allow diagonal movement
_diagonal_movement = false;
// How much we delay before accepting an input when our character is stationary.
// Only applies for diagonal movement, b/c we can't expect frame perfect inputs
// from our player
_diagonal_delay = 5;

// How much progress we make towards a tile per frame
_move_speed = 1.0/17.0;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Movement and Orientation Util

// Inputs
_input_x = 0;
_input_y = 0;
// the input we held at the last tile
_last_tile_input_x = _input_x;
_last_tile_input_y = _input_y;


// current and target position
_current_tile_x = 0;
_current_tile_y = 0;
_delta_tile_x = 0; // the actual delta
_delta_tile_y = 0;


// where the character appears to be
_draw_x = 0;
_draw_y = 0;

// the percentage that we reached our target tile.
// 0 is our current tile
// 1 is our target tile. Once we reach this we're done.
_target_progress = 0;

// which way we're looking
_orientation = dir_up;

// which way we're told to look
_target_orientation = _orientation;

// Are we moving this frame?
_moving_this_frame = false;

// Did we take a step?
_took_step = false;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// END OF DIAGONAL INPUT WAIT
__character_update_delta_tile(_input_x, _input_y);

// Immediately move
_moving_this_frame = true;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Player Movement

if character_get_player() == id {
    // Arrow keys
    var xaxis = keyboard_check(vk_right) - keyboard_check(vk_left),
        yaxis = keyboard_check(vk_down)  - keyboard_check(vk_up);
    // Vim??!! (rpgmaker was made in vim confirmed!)
    xaxis += keyboard_check(ord("L")) - keyboard_check(ord("H"));
    yaxis += keyboard_check(ord("J")) - keyboard_check(ord("K"));

    xaxis = clamp(xaxis, -1, 1);
    yaxis = clamp(yaxis, -1, 1);
    character_move(id, xaxis, yaxis);

}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Orient self (for frame alignment)
_orientation = _target_orientation;

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Move to reach the target

_took_step = false;
if character_is_moving(id) {
    // We're moving
    if (_target_progress == 0) {
        // First step
        __character_bump_sprite();    
    }

    _target_progress += _move_speed;
    if (_target_progress &gt;= 1) {
        _took_step = true;

        _current_tile_x += _delta_tile_x;
        _current_tile_y += _delta_tile_y;

        __character_handle_input();

        var keep_moving = false;
        if _delta_tile_x != 0 || _delta_tile_y != 0
            keep_moving = true;
        // Override: If we're the player and we're waiting on the menu, don't move.
        if character_get_player() == id &amp;&amp; __menu_is_waiting_to_open() {
            keep_moving = false;
            _delta_tile_x = 0;
            _delta_tile_y = 0;
        }
        // Should we stop or can we still push forward?
        if keep_moving {
            // We can still move on
            // This checks for collisions
            __character_update_delta_tile(_delta_tile_x, _delta_tile_y);
            _target_progress -= 1; // %= 1
        } else {
            // We stopped
            _target_progress = 0;
        }

        // Reset sprite (TODO: Function for "on tile enter" event?)
        __character_reset_sprite_resting();
        
        // Check for events
        var event = event_get(character_get_tile_x(id), character_get_tile_y(id));
        // Touch event
        if event != noone &amp;&amp; event_get_trigger(event) == EventTrigger.Touch {
            event_call_script(event);
        }
    }
} else {
    // We're not moving, so accept all inputs
    __character_handle_input();
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Action events

if  character_get_player() == id
    &amp;&amp; __character_can_move() 
    &amp;&amp; !character_is_moving(id) 
    &amp;&amp; __dialogue_check_progress_pressed() {
    var fx = character_get_facing_tile_x(id),
        fy = character_get_facing_tile_y(id);
    var event = event_get(fx, fy);
    // Touch event
    if event != noone &amp;&amp; event_get_trigger(event) == EventTrigger.Action {
        event_call_script(event);
    }    
}


</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Sprite control
if character_is_moving(id) {
    // move speed controls percent per frame
    var img_spd = _move_speed * _movement_frames_per_tile;

    // If we haven't snapped back
    if (_target_progress != 0) {
        _movement_image_index += img_spd;
    }
} else {
    __character_reset_sprite_resting();
}

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw position

// the positions of our current and target tiles
var current_x = tilemap_global_get_pos_x(_current_tile_x),
    current_y = tilemap_global_get_pos_y(_current_tile_y),
    target_x  = tilemap_global_get_pos_x(_current_tile_x + _delta_tile_x),
    target_y  = tilemap_global_get_pos_y(_current_tile_y + _delta_tile_y);

// lerp between current and target positions
_draw_x = lerp(current_x, target_x, _target_progress);
_draw_y = lerp(current_y, target_y, _target_progress);

</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Moving this frame?

_moving_this_frame = (_delta_tile_x != 0) || (_delta_tile_y != 0);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Player camera
if character_get_player() == id {
    view_follow_character(id, true);
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw character animated
draw_set_alpha(1);

if _movement_sprite != -1 {
    // convert our movement image index to an actual image index.
    // img_index is a (0 1 2 1 ...) repeating cycle
    var img_index = floor(_movement_image_index) % 4;
    if (img_index == 3) img_index = 1;

    // We effectively chop up the image into 4 rows 
    // of 3 (or more, depending on _movement_image_number) columns.

    // The width and height of one character frame
    var char_width  = _movement_sprite_width / 3,
        char_height = _movement_sprite_height / 4;

    // We made sure that the orientation values followed the order of the sprite frames.
    // Take a look at a character movement template to see the vertical offsets
    var left = _movement_sprite_left  + char_width  * img_index,
        top  = _movement_sprite_top + char_height * _orientation;

    // draw_x and draw_y but with no origin
    var real_draw_x = _draw_x - _movement_origin_x;
        real_draw_y = _draw_y - _movement_origin_y;
        
    //real_draw_x = round(real_draw_x);
    //real_draw_y = round(real_draw_y);


    draw_sprite_part(_movement_sprite, 
                     _movement_sprite_subimg, 
                     left,
                     top,
                     char_width,
                     char_height,
                     real_draw_x,
                     real_draw_y
    );
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
